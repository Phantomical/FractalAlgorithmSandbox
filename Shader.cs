// <auto-generated>
//	This code was generated by a Tool.
//
//	Changes to this file may cause incorrect behavior and will be lost if
//	the code is regenerated.
// <auto-generated>

using System;
using GL = global::OpenTK.Graphics.OpenGL.GL;

#pragma warning disable 168

namespace Shaders
{
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("ShaderCompiler.exe", "0.1.10")]
	public class PlaneShader : global::ShaderRuntime.GLShader
	{
		public static bool ImplementationSupportsShaders
		{
			get
			{
				return (new Version(GL.GetString(global::OpenTK.Graphics.OpenGL.StringName.Version).Substring(0, 3)) >= new Version(2, 0) ? true : false);
			}
		}
		static int ProgramID;
		private static global::ShaderRuntime.Utility.Counter Ctr = new global::ShaderRuntime.Utility.Counter(new Action(delegate{ GL.DeleteProgram(ProgramID); ProgramID = 0; }));
		public bool TransposeMatrix = false;
		public static int __LightDir;
		public global::OpenTK.Vector3 uniform_LightDir;
		public static int __MVP;
		public global::OpenTK.Matrix4 uniform_MVP;
		public static int __Normal;
		public static int __Vertex;
		private static string VertexSource = "#version 330\n\nin vec3 Vertex;\nin vec3 Normal;\n\nuniform mat4 MVP;\n\nsmooth out float displacement;\nsmooth out vec3 normal;\n\nvoid main()\n{\n	gl_Position = MVP * vec4(Vertex, 1.0);\n	displacement = Vertex.y;\n	normal = Normal;\n}";
		private static string FragmentSource = "#version 330\n\nuniform vec3 LightDir;\n\nin float displacement;\nin vec3 normal;\n\nout vec3 Colour;\n\nvoid main()\n{\n	Colour = vec3(clamp( dot( normal, -LightDir ), 0.0,1.0 ));\n}";
		private static void LoadShaders()
		{
			VertexSource = global::System.IO.File.ReadAllText(@"D:\Projects\Projects\C#\FractalAlgorithmSandbox\Shader.vert");
			FragmentSource = global::System.IO.File.ReadAllText(@"D:\Projects\Projects\C#\FractalAlgorithmSandbox\Shader.frag");
		}
		public static void CompileShader()
		{
			LoadShaders();
			ProgramID = GL.CreateProgram();
			int Vertex = GL.CreateShader(global::OpenTK.Graphics.OpenGL.ShaderType.VertexShader);
			GL.ShaderSource(Vertex, VertexSource);
			GL.CompileShader(Vertex);
			GL.AttachShader(ProgramID, Vertex);
			int Fragment = GL.CreateShader(global::OpenTK.Graphics.OpenGL.ShaderType.FragmentShader);
			GL.ShaderSource(Fragment, FragmentSource);
			GL.CompileShader(Fragment);
			GL.AttachShader(ProgramID, Fragment);
			GL.LinkProgram(ProgramID);
			global::System.Diagnostics.Debug.WriteLine(GL.GetProgramInfoLog(ProgramID));
			GL.DetachShader(ProgramID, Vertex);
			GL.DeleteShader(Vertex);
			GL.DetachShader(ProgramID, Fragment);
			GL.DeleteShader(Fragment);
			__LightDir = GL.GetUniformLocation(ProgramID, "LightDir");
			__MVP = GL.GetUniformLocation(ProgramID, "MVP");
			__Normal = GL.GetAttribLocation(ProgramID, "Normal");
			__Vertex = GL.GetAttribLocation(ProgramID, "Vertex");
		}
		public void Recompile()
		{
			GL.DeleteShader(ProgramID);
			ProgramID = 0;
			Compile();
		}
		public void Compile()
		{
			if(ProgramID == 0)
				CompileShader();
			Ctr++;
		}
		public void SetParameter<T>(string name, T value)
		{
			try
			{
				switch(name)
				{
					case "LightDir":
						uniform_LightDir = (global::OpenTK.Vector3)(object)value;
						break;
					case "MVP":
						uniform_MVP = (global::OpenTK.Matrix4)(object)value;
						break;
					default:
						throw new global::ShaderRuntime.InvalidIdentifierException("There is no uniform variable named " + name + " in this shader.");
				}
			}
			catch(InvalidCastException e)
			{
				throw new global::ShaderRuntime.InvalidParameterTypeException("Invalid parameter type: " + name + " is not convertible from the type \"" + typeof(T).FullName + "\".");
			}
		}
		public T GetParameter<T>(string name)
		{
			try
			{
				switch(name)
				{
					case "LightDir":
						return (T)(object)uniform_LightDir;
					case "MVP":
						return (T)(object)uniform_MVP;
					default:
						throw new global::ShaderRuntime.InvalidIdentifierException("There is no uniform variable named " + name + " in this shader.");
				}
			}
			catch(InvalidCastException e)
			{
				throw new global::ShaderRuntime.InvalidParameterTypeException("Invalid paramater type: " + name + " is not convertible to the type \"" + typeof(T).FullName + "\".");
			}
		}
		public int GetParameterLocation(string name)
		{
			switch(name)
			{
				case "LightDir":
					return __LightDir;
				case "MVP":
					return __MVP;
				case "Normal":
					return __Normal;
				case "Vertex":
					return __Vertex;
				default:
					throw new global::ShaderRuntime.InvalidIdentifierException("There is no parameter named " + name + ".");
			}
		}
		public void PassUniforms()
		{
			GL.Uniform3(__LightDir, uniform_LightDir);
			GL.UniformMatrix4(__MVP, TransposeMatrix, ref uniform_MVP);
		}
		public void UseShader()
		{
			GL.UseProgram(ProgramID);
			GL.EnableVertexAttribArray(__Normal);
			GL.EnableVertexAttribArray(__Vertex);
		}
		public int GetShaderID()
		{
			if(ProgramID != 0)
				return ProgramID;
			throw new global::ShaderRuntime.ShaderNotInitializedException("The shader \"PlaneShader\" has not been initialized. Call Compile() on one of the instances or CompileShader() to compile the shader");
		}
		public void Dispose()
		{
			Ctr--;
		}
		public bool IsSupported
		{
			get
			{
				return ImplementationSupportsShaders;
			}
		}
		public global::System.Collections.Generic.IEnumerable<string> GetUniformNames()
		{
			yield return "LightDir";
			yield return "MVP";
		}
	}
}
